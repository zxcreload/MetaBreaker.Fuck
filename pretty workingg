--[[ Adonis Anti-Cheat Bypass ]]
for _, v in pairs(getgc(true)) do
    if type(v) == "table" then
        setreadonly(v, false)
        if type(rawget(v, "indexInstance")) == "table" and rawget(v, "indexInstance")[1] == "kick" then
            setreadonly(rawget(v, "indexInstance"), false)
            rawset(v, "Table", {"kick", function() coroutine.yield() end})
            warn("\n---[ INFO ]---\nBypassed Adonis Anti-Cheat/Anti-Exploit.\nMethod: Prevented Script Table Communication With Server.")
            break
        end
    end
end

--[[ Silent Aim Settings ]]
getgenv().SilentAim = {
    Enabled = true,
    MultiConfigPredictionEnabled = false,
    DefaultPrediction = 0.161123123,
    PredictionConfigs = {
        {Distance = 50, PredictionXZ = 0.12, PredictionY = 0.12},
        {Distance = 100, PredictionXZ = 0.14, PredictionY = 0.14},
        {Distance = 1000, PredictionXZ = 0.16, PredictionY = 0.16},
        {Distance = 10000, PredictionXZ = 0.18, PredictionY = 0.18}
    },
    TargetParts = {
        "HumanoidRootPart", "UpperTorso", "LowerTorso", "Head",
        "LeftUpperArm", "RightUpperArm", "LeftLowerArm", "RightLowerArm",
        "LeftUpperLeg", "RightUpperLeg", "LeftLowerLeg", "RightLowerLeg",
        "UpperLegs", "LowerLegs", "Legs"
    },
    JumpAimPart = "UpperLegs",
    VisibleCheck = true,
    HitChance = 100,
    Keybind = Enum.KeyCode.Q,
    IgnoreRagdoll = false,
    IgnoreGrabbed = false,
    WallCheck = false,
    TargetSelectionMode = "Keybind",
    Whitelist = {"ExamplePlayer", "Friend", "Admin"},
    WhitelistEnabled = false,
    ReacquisitionMode = "Immediate",
    PriorityList = {"Enemy1", "Enemy2", "Enemy3"},
    KeepTargetOnDeath = true,
    ResolverMode = "Velocity",
    ResolverKeybind = Enum.KeyCode.J,
    IndicatorEnabled = true,
    IndicatorFontSize = 12,
    IndicatorFont = Enum.Font.Sarpanch,
    GradientColors = {
        Start = {ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 170, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))},
        End = {ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 170, 255))}
    },
    DamageIndicatorDuration = 2,
    MaxDamageIndicators = 3,
    MinDamageIndicatorInterval = 0.2,
    HitSounds = {
        hitmarker = 705502934,
        rust = 5043539486,
        CSHS = 9065951723,
        CoD = 5952120301,
        Minecraft = 8837706727
    },
    SelectedHitSound = "hitmarker",
    HitSoundPitch = 1,
    HitSoundVolume = 0.5,
    DesyncStomp = {
        Enabled = true,
        StompCount = 5,
        StompInterval = 0.1,
        YOffset = 2,
        UnequipWeaponDuringDesync = true,
        ToggleKeybind = Enum.KeyCode.T
    }
}

-- Services (reused throughout the script)
local Players, Workspace, RunService, UserInputService, TweenService, ReplicatedStorage = 
    game:GetService("Players"), game:GetService("Workspace"), game:GetService("RunService"),
    game:GetService("UserInputService"), game:GetService("TweenService"), game:GetService("ReplicatedStorage")

-- Core variables (minimized locals)
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local SilentAim = getgenv().SilentAim
local ScreenGui = Instance.new("ScreenGui", game.CoreGui); ScreenGui.Name = "SilentAimIndicators"; ScreenGui.IgnoreGuiInset = true
local Camera = Workspace.CurrentCamera
local Char, HRP, Humanoid

-- Wait for character with a timeout to prevent nil errors on executors
local timeout = 10
local startTime = tick()
while not LocalPlayer.Character and (tick() - startTime) < timeout do
    LocalPlayer.CharacterAdded:Wait()
end
Char = LocalPlayer.Character or error("Failed to load LocalPlayer.Character after " .. timeout .. " seconds")
HRP = Char:WaitForChild("HumanoidRootPart", 5) or error("HumanoidRootPart not found")
Humanoid = Char:WaitForChild("Humanoid", 5) or error("Humanoid not found")

-- Watermark UI (reusing services, minimizing locals)
local watermark = Instance.new("ScreenGui")
watermark.Name = "WatermarkUI"
watermark.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
watermark.ResetOnSpawn = false
watermark.Parent = LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Name = "MainFrame"
frame.BorderSizePixel = 0
frame.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
frame.Size = UDim2.new(0, 236, 0, 33)
frame.Position = UDim2.new(1, -250, 0, 10)
frame.Parent = watermark
frame.ClipsDescendants = true

local accentLine = Instance.new("Frame")
accentLine.Name = "AccentLine"
accentLine.BorderSizePixel = 0
accentLine.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
accentLine.Size = UDim2.new(0, 232, 0, 2)
accentLine.Position = UDim2.new(0.008, 0, 0.184, 0)
accentLine.Parent = frame

local accentGradient = Instance.new("UIGradient")
accentGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 180, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 100, 255))
})
accentGradient.Parent = accentLine

local textContainer = Instance.new("Frame")
textContainer.Name = "TextContainer"
textContainer.ZIndex = 20
textContainer.BorderSizePixel = 0
textContainer.BackgroundTransparency = 1
textContainer.Size = UDim2.new(1, -20, 0, 24)
textContainer.Position = UDim2.new(0, 10, 0.244, 0)
textContainer.Parent = frame

Instance.new("UIStroke").Thickness = 0.8
Instance.new("UIStroke").Color = Color3.fromRGB(87, 87, 87)
Instance.new("UIStroke").Parent = textContainer

local textLabel = Instance.new("TextLabel")
textLabel.Name = "WatermarkText"
textLabel.TextWrapped = true
textLabel.TextSize = 16
textLabel.Font = Enum.Font.SourceSansBold
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.BackgroundTransparency = 1
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.Text = "metaBreakerEnhanced.lua"
textLabel.Parent = textContainer

local textGradient = Instance.new("UIGradient")
textGradient.Rotation = -147
textGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 180, 255)),
    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 255)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 100, 255))
})
textGradient.Parent = textLabel

local gradientTime, animationSpeed = 0, 0.2
local dragging, dragStart, startPos, dragTween = false

local function smoothUpdate(input)
    if not dragging then return end
    
    if dragTween then dragTween:Cancel() end
    
    dragTween = TweenService:Create(
        frame,
        TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        {Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + (input.Position - dragStart).X, startPos.Y.Scale, startPos.Y.Offset + (input.Position - dragStart).Y)}
    )
    dragTween:Play()
end

frame.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = frame.Position
        
        TweenService:Create(frame, TweenInfo.new(0.1), {BackgroundColor3 = Color3.fromRGB(60, 60, 60)}):Play()
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
                TweenService:Create(frame, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(45, 45, 45)}):Play()
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then smoothUpdate(input) end
end)

frame.Size = UDim2.new(0, 0, 0, 33)
frame.Visible = true
TweenService:Create(frame, TweenInfo.new(0.7, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {Size = UDim2.new(0, 236, 0, 33)}):Play()

-- Beam and Desync Variables (minimized locals)
local Beam, StartAttachment, EndAttachment
local followPart, desyncBoxESP, stompCounter, lastStompTime, isDesyncActive, desyncAppliedToTarget, targetKOStates, lastEquippedTool = nil, nil, 0, nil, false, {}, {}, nil

-- Initialize Beam
local function InitBeam()
    if Beam then Beam:Destroy() end
    if StartAttachment then StartAttachment:Destroy() end
    if EndAttachment then EndAttachment:Destroy() end

    StartAttachment = Instance.new("Attachment")
    EndAttachment = Instance.new("Attachment")
    Beam = Instance.new("Beam")
    Beam.Color = ColorSequence.new(SilentAim.GradientColors.Start)
    Beam.Width0 = 0.2
    Beam.Width1 = 0.2
    Beam.Transparency = NumberSequence.new(0)
    Beam.Attachment0 = StartAttachment
    Beam.Attachment1 = EndAttachment
    Beam.Enabled = false
    Beam.Parent = Workspace
end

InitBeam()

SilentAim.Selected, SilentAim.SelectedPart, SilentAim.PreviousTarget = nil, nil, nil
local lastPosition, lastUpdateTime = nil, nil

-- Indicators (minimized locals)
local Indicators = {Damage = {}}
local lastIndicatorTime, pendingDamage, gradientsToAnimate = 0, nil, {}

local function CreateIndicator(name, text, offsetY, animate, isDamageIndicator)
    local f = Instance.new("Frame")
    f.Name = name
    f.Size = UDim2.new(0, 200, 0, name == "Cheatname" and 24 or 20)
    f.BackgroundTransparency = 1
    f.Parent = ScreenGui

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = text
    label.TextSize = name == "Cheatname" and SilentAim.IndicatorFontSize + 2 or SilentAim.IndicatorFontSize
    label.Font = SilentAim.IndicatorFont
    label.TextColor3 = isDamageIndicator and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(255, 255, 255)
    label.TextStrokeTransparency = 0.8
    label.TextXAlignment = Enum.TextXAlignment.Center
    label.Parent = f

    if not isDamageIndicator then
        local gradient = Instance.new("UIGradient")
        gradient.Color = ColorSequence.new(SilentAim.GradientColors.Start)
        gradient.Parent = label
        table.insert(gradientsToAnimate, gradient)
    end

    f.Position = animate and UDim2.new(0.5, -300, 0.5, offsetY) or UDim2.new(0.5, -100, 0.5, offsetY)
    if animate then
        TweenService:Create(f, TweenInfo.new(0.7, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Position = UDim2.new(0.5, -100, 0.5, offsetY)}):Play()
    end

    return f, label
end

local function ShowDamageIndicator(targetName, damage, remainingHP)
    warn("[DEBUG] ShowDamageIndicator called for " .. tostring(targetName) .. " with damage " .. tostring(damage) .. " and remaining HP " .. tostring(remainingHP))

    if not targetName or not damage or not remainingHP then
        warn("[DEBUG] Invalid arguments in ShowDamageIndicator: targetName=" .. tostring(targetName) .. ", damage=" .. tostring(damage) .. ", remainingHP=" .. tostring(remainingHP))
        return
    end

    local currentTime = tick()
    local timeSinceLast = currentTime - lastIndicatorTime

    local hitSound = Instance.new("Sound")
    hitSound.Parent = game.CoreGui
    hitSound.SoundId = "rbxassetid://" .. (SilentAim.HitSounds[SilentAim.SelectedHitSound] or SilentAim.HitSounds.hitmarker)
    hitSound.PlaybackSpeed = SilentAim.HitSoundPitch
    hitSound.Volume = SilentAim.HitSoundVolume
    hitSound.PlayOnRemove = true
    hitSound:Destroy()

    if timeSinceLast < SilentAim.MinDamageIndicatorInterval and Indicators.Damage[#Indicators.Damage] then
        pendingDamage = pendingDamage or {damage = 0, remainingHP = remainingHP}
        pendingDamage.damage = pendingDamage.damage + damage
        Indicators.Damage[#Indicators.Damage].TextLabel.Text = string.format("hit %s %d (%d)", targetName, pendingDamage.damage, pendingDamage.remainingHP)
        warn("[DEBUG] Updated existing hitlog: " .. string.format("hit %s %d (%d)", targetName, pendingDamage.damage, pendingDamage.remainingHP))
        return
    end

    local totalDamage = damage + (pendingDamage and pendingDamage.damage or 0)
    remainingHP = pendingDamage and pendingDamage.remainingHP or remainingHP
    pendingDamage = nil

    local text = string.format("hit %s %d (%d)", targetName, totalDamage, remainingHP)
    local offsetY = 160 + (#Indicators.Damage * 10)
    local success, dmgIndicator, dmgLabel = pcall(CreateIndicator, "Damage_" .. tostring(tick()), text, offsetY, true, true)
    if not success then
        warn("[DEBUG] Failed to create damage indicator: " .. tostring(dmgIndicator))
        return
    end

    table.insert(Indicators.Damage, dmgIndicator)
    lastIndicatorTime = currentTime

    if #Indicators.Damage > SilentAim.MaxDamageIndicators then
        local oldest = table.remove(Indicators.Damage, 1)
        if oldest then oldest:Destroy() end
    end

    for i, indicator in ipairs(Indicators.Damage) do
        indicator.Position = UDim2.new(0.5, -100, 0.5, 160 + ((i - 1) * 10))
    end

    local fadeTween = TweenService:Create(dmgLabel, TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {TextTransparency = 1, TextStrokeTransparency = 1})
    task.delay(SilentAim.DamageIndicatorDuration - 0.5, function()
        fadeTween:Play()
        fadeTween.Completed:Connect(function()
            for i, v in ipairs(Indicators.Damage) do
                if v == dmgIndicator then
                    table.remove(Indicators.Damage, i)
                    v:Destroy()
                    break
                end
            end
            for i, indicator in ipairs(Indicators.Damage) do
                indicator.Position = UDim2.new(0.5, -100, 0.5, 160 + ((i - 1) * 10))
            end
        end)
    end)

    warn("[DEBUG] New hitlog created: " .. text)
end

local function InitIndicators()
    Indicators.Cheatname = CreateIndicator("Cheatname", "metaBreakerEnhanced.lua", 106, false, false)
    Indicators.TargetHP = CreateIndicator("TargetHP", "Target HP: N/A", 120, false, false)
    Indicators.LocalHP = CreateIndicator("LocalHP", "Local HP: N/A", 130, false, false)
    Indicators.Distance = CreateIndicator("Distance", "Distance: N/A", 140, false, false)
    Indicators.DesyncStompStatus = CreateIndicator("DesyncStompStatus", "Autostomp: " .. (SilentAim.DesyncStomp.Enabled and "Enabled" or "Disabled"), 150, false, false)
end

if SilentAim.IndicatorEnabled then InitIndicators() end

local function LerpColor(color1, color2, t)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local gradientAnimationConnection
local function StartGradientAnimation()
    if gradientAnimationConnection then gradientAnimationConnection:Disconnect() end

    -- Add watermark gradients to the animation list to ensure they are updated
    table.insert(gradientsToAnimate, accentGradient)
    table.insert(gradientsToAnimate, textGradient)

    local startTime = tick()
    local duration = 2

    gradientAnimationConnection = RunService.Heartbeat:Connect(function(deltaTime)
        local elapsed = (tick() - startTime) % duration
        local t = elapsed / duration

        -- Update color gradients for all UI elements
        local startKeypoints = SilentAim.GradientColors.Start
        local endKeypoints = SilentAim.GradientColors.End

        local newKeypoints = {}
        for i = 1, math.max(#startKeypoints, #endKeypoints) do
            local startPoint = startKeypoints[i] or startKeypoints[#startKeypoints]
            local endPoint = endKeypoints[i] or endKeypoints[#endKeypoints]
            table.insert(newKeypoints, ColorSequenceKeypoint.new(startPoint.Time, LerpColor(startPoint.Value, endPoint.Value, t)))
        end

        -- Apply the color gradient to all animated elements
        for _, gradient in ipairs(gradientsToAnimate) do
            if gradient and gradient.Parent then
                gradient.Color = ColorSequence.new(newKeypoints)
            end
        end

        if Beam and Beam.Parent then
            Beam.Color = ColorSequence.new(newKeypoints)
        end

        -- Update the gradient offset and rotation for watermark
        gradientTime = gradientTime + deltaTime * animationSpeed
        if gradientTime > 1 then gradientTime = 0 end

        local offset = math.sin(gradientTime * math.pi * 2) * 0.1
        local rotation = -147 + math.sin(gradientTime * math.pi) * 15

        -- Apply offset and rotation to watermark gradients
        if accentGradient and accentGradient.Parent then
            accentGradient.Offset = Vector2.new(offset, 0)
        end
        if textGradient and textGradient.Parent then
            textGradient.Offset = Vector2.new(offset, 0)
            textGradient.Rotation = rotation
        end
    end)
end

StartGradientAnimation()

local function GetPredictionForDistance(distance)
    if not SilentAim.MultiConfigPredictionEnabled then return SilentAim.DefaultPrediction, SilentAim.DefaultPrediction end

    local selectedConfig = SilentAim.PredictionConfigs[1]
    for _, config in ipairs(SilentAim.PredictionConfigs) do
        if distance <= config.Distance then
            selectedConfig = config
            break
        end
    end
    return selectedConfig.PredictionXZ, selectedConfig.PredictionY
end

local function getPredictedPosition(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("Humanoid") then return nil end

    local aimPart = SilentAim.SelectedPart or targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not aimPart then return nil end
    
    local aimPartPos = aimPart.Position
    
    if not lastPosition or not lastUpdateTime then
        lastPosition = aimPartPos
        lastUpdateTime = tick()
        return aimPartPos
    end

    local currentTime = tick()
    local deltaTime = currentTime - lastUpdateTime

    local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local distance = localRoot and (localRoot.Position - aimPartPos).Magnitude or math.huge
    local predictionXZ, predictionY = GetPredictionForDistance(distance)
    
    if SilentAim.ResolverMode == "Velocity" then
        local velocity = aimPart.Velocity
        return aimPartPos + Vector3.new(velocity.X * predictionXZ, velocity.Y * predictionY, velocity.Z * predictionXZ)
    elseif SilentAim.ResolverMode == "MoveDirection" then
        return aimPartPos + (targetPlayer.Character.Humanoid.MoveDirection * (predictionXZ * 10))
    elseif SilentAim.ResolverMode == "CalculateCFrame" then
        if (aimPartPos - lastPosition).Magnitude < 0.001 then
            return aimPartPos 
        else
            local distance = (aimPartPos - lastPosition).Magnitude
            local predictedDistance = (distance / deltaTime) * (0.1 * (predictionXZ * 10))
            local predictedPosition = aimPartPos + (aimPartPos - lastPosition).Unit * predictedDistance
            
            local yChange = (aimPartPos.Y - lastPosition.Y) / deltaTime * (0.1 * predictionY)
            predictedPosition = predictedPosition + Vector3.new(0, yChange, 0)
            
            lastUpdateTime = currentTime
            lastPosition = aimPartPos
            return predictedPosition
        end
    end
    return nil
end

local function CalcChance(p)
    return math.random() * 100 <= p
end

local function IsPartVisible(part, char)
    if not part or not char or not Camera then return false end

    local origin = Camera.CFrame.Position
    local _, onScreen = Camera:WorldToViewportPoint(part.Position)

    if onScreen then
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Blacklist
        rayParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
        local result = Workspace:Raycast(origin, part.Position - origin, rayParams)
        return not result or result.Instance:IsDescendantOf(char)
    end

    return false
end

local function IsWhitelisted(player)
    if not SilentAim.WhitelistEnabled then return true end
    
    for _, namePart in ipairs(SilentAim.Whitelist) do
        if string.find(player.Name:lower(), namePart:lower(), 1, true) then return true end
    end
    
    return false
end

local function GetCombinedPart(char, partType)
    if not char then return nil end

    local leftPart, rightPart
    
    if partType == "UpperLegs" then
        leftPart = char:FindFirstChild("LeftUpperLeg")
        rightPart = char:FindFirstChild("RightUpperLeg")
    elseif partType == "LowerLegs" then
        leftPart = char:FindFirstChild("LeftLowerLeg")
        rightPart = char:FindFirstChild("RightLowerLeg")
    elseif partType == "Legs" then
        leftPart = char:FindFirstChild("LeftUpperLeg") or char:FindFirstChild("LeftLowerLeg")
        rightPart = char:FindFirstChild("RightUpperLeg") or char:FindFirstChild("RightLowerLeg")
    end
    
    if not leftPart or not rightPart then return nil end
    
    local combinedPart = Instance.new("Part")
    combinedPart.Size = Vector3.new(0.1, 0.1, 0.1)
    combinedPart.Transparency = 1
    combinedPart.CanCollide = false
    combinedPart.Anchored = true
    combinedPart.Position = (leftPart.Position + rightPart.Position) / 2
    combinedPart.Velocity = (leftPart.Velocity + rightPart.Velocity) / 2
    
    return combinedPart
end

local function ClosestPart(char)
    if not char or not char.Parent or not char:IsDescendantOf(Workspace) or not char:FindFirstChild("Humanoid") or not Camera then return nil end

    local isJumping = char.Humanoid:GetState() == Enum.HumanoidStateType.Jumping

    if isJumping and SilentAim.JumpAimPart then
        local jumpPart = char:FindFirstChild(SilentAim.JumpAimPart) or (SilentAim.JumpAimPart:find("Legs") and GetCombinedPart(char, SilentAim.JumpAimPart))
        if jumpPart and (not SilentAim.WallCheck or IsPartVisible(jumpPart, char)) then
            local _, onScreen = Camera:WorldToViewportPoint(jumpPart.Position)
            if onScreen then return jumpPart end
        end
    end

    for _, partName in ipairs(SilentAim.TargetParts) do
        if not char.Parent or not char:IsDescendantOf(Workspace) then return nil end
        local part = char:FindFirstChild(partName) or (partName:find("Legs") and GetCombinedPart(char, partName))
        if part and (not SilentAim.WallCheck or IsPartVisible(part, char)) then
            local _, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then return part end
        end
    end

    return nil
end

local function ReacquireTarget()
    if not SilentAim.KeepTargetOnDeath then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        return
    end

    if SilentAim.ReacquisitionMode == "Immediate" then
        if SilentAim.PreviousTarget and SilentAim.PreviousTarget.Parent and SilentAim.PreviousTarget:IsDescendantOf(Players) then
            local player = SilentAim.PreviousTarget
            if player.Character and player.Character.Parent and player.Character:IsDescendantOf(Workspace) then
                SilentAim.Selected = player
                SilentAim.SelectedPart = ClosestPart(player.Character)
                if SilentAim.SelectedPart then MonitorDamage() end
            else
                local connection
                connection = player.CharacterAdded:Connect(function(char)
                    if not player or not player.Parent or not player:IsDescendantOf(Players) then
                        connection:Disconnect()
                        return
                    end
                    SilentAim.Selected = player
                    SilentAim.SelectedPart = ClosestPart(char)
                    if SilentAim.SelectedPart then MonitorDamage() end
                    connection:Disconnect()
                end)
            end
        else
            SilentAim.Selected, SilentAim.SelectedPart, SilentAim.PreviousTarget = nil, nil, nil
        end
    elseif SilentAim.ReacquisitionMode == "Nearest" then
        GetClosest()
        if SilentAim.Selected and SilentAim.Selected ~= LocalPlayer then
            SilentAim.PreviousTarget = SilentAim.Selected
            MonitorDamage()
        end
    elseif SilentAim.ReacquisitionMode == "Priority" then
        for _, playerName in ipairs(SilentAim.PriorityList) do
            local player = Players:FindFirstChild(playerName)
            if player and player ~= LocalPlayer and player.Character and IsWhitelisted(player) then
                local part = ClosestPart(player.Character)
                if part and (not SilentAim.VisibleCheck or IsPartVisible(part, player.Character)) then
                    SilentAim.Selected = player
                    SilentAim.SelectedPart = part
                    SilentAim.PreviousTarget = player
                    MonitorDamage()
                    return
                end
            end
        end
        GetClosest()
        if SilentAim.Selected and SilentAim.Selected ~= LocalPlayer then
            SilentAim.PreviousTarget = SilentAim.Selected
            MonitorDamage()
        end
    end
end

local function Check()
    if not (SilentAim.Enabled and SilentAim.Selected and SilentAim.Selected ~= LocalPlayer) then return false end

    if not SilentAim.Selected.Parent or not SilentAim.Selected:IsDescendantOf(Players) then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return false
    end

    local char = SilentAim.Selected.Character
    if not char or not char.Parent or not char:IsDescendantOf(Workspace) or not char:FindFirstChild("Humanoid") then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return false
    end

    if not SilentAim.KeepTargetOnDeath and char.Humanoid.Health <= 0 then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return false
    end

    local bodyEffects = char:FindFirstChild("BodyEffects")
    if not bodyEffects or not bodyEffects:FindFirstChild("K.O") then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return false
    end

    local koValue = bodyEffects["K.O"].Value
    local grabbed = char:FindFirstChild("GRABBING_CONSTRAINT") ~= nil

    if (SilentAim.IgnoreRagdoll and koValue and not SilentAim.DesyncStomp.Enabled) or (SilentAim.IgnoreGrabbed and grabbed) then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return false
    end

    if not SilentAim.SelectedPart or not SilentAim.SelectedPart.Parent or not SilentAim.SelectedPart:IsDescendantOf(char) then
        SilentAim.SelectedPart = ClosestPart(char)
        if not SilentAim.SelectedPart then
            SilentAim.Selected, SilentAim.SelectedPart = nil, nil
            ReacquireTarget()
            return false
        end
    end

    return true
end

local function GetClosest()
    if not CalcChance(SilentAim.HitChance) then
        SilentAim.Selected, SilentAim.SelectedPart = LocalPlayer, nil
        return
    end

    local closest, shortest, targetPart = nil, math.huge, nil

    if not Camera then
        SilentAim.Selected, SilentAim.SelectedPart = LocalPlayer, nil
        return
    end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == LocalPlayer or not IsWhitelisted(plr) or not plr.Parent or not plr:IsDescendantOf(Players) then continue end

        local char = plr.Character
        if char and char.Parent and char:IsDescendantOf(Workspace) and char:FindFirstChild("Humanoid") then
            local part = ClosestPart(char)
            if part then
                local pos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if not onScreen then continue end
                local dist = (Vector2.new(pos.X, pos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude

                if dist < shortest and (not SilentAim.VisibleCheck or IsPartVisible(part, char)) then
                    closest = plr
                    targetPart = part
                    shortest = dist
                end
            end
        end
    end

    SilentAim.Selected = closest or LocalPlayer
    SilentAim.SelectedPart = targetPart
    if closest then SilentAim.PreviousTarget = closest end
end

local function UpdateIndicators()
    if not SilentAim.IndicatorEnabled then return end

    local localHP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") and math.floor(LocalPlayer.Character.Humanoid.Health) or "N/A"
    Indicators.LocalHP.TextLabel.Text = "Local HP: " .. tostring(localHP)

    if Check() then
        local targetHP = SilentAim.Selected.Character:FindFirstChild("Humanoid") and math.floor(SilentAim.Selected.Character.Humanoid.Health) or "N/A"
        Indicators.TargetHP.TextLabel.Text = "Target HP: " .. tostring(targetHP)

        local distance = (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and SilentAim.SelectedPart) and 
            math.floor((LocalPlayer.Character.HumanoidRootPart.Position - SilentAim.SelectedPart.Position).Magnitude) or "N/A"
        Indicators.Distance.TextLabel.Text = "Distance: " .. tostring(distance)
    else
        Indicators.TargetHP.TextLabel.Text = "Target HP: N/A"
        Indicators.Distance.TextLabel.Text = "Distance: N/A"
    end
end

local function UpdateTracer()
    Beam.Enabled = false
    if not Check() then return end

    local lChar = LocalPlayer.Character
    if not lChar or not lChar:FindFirstChild("Head") then return end

    local tChar = SilentAim.Selected and SilentAim.Selected.Character
    if not tChar or not tChar.Parent or not tChar:IsDescendantOf(Workspace) then
        SilentAim.Selected, SilentAim.SelectedPart = nil, nil
        ReacquireTarget()
        return
    end

    local tPart = SilentAim.SelectedPart
    if not tPart or not tPart.Parent or not tPart:IsDescendantOf(tChar) then
        SilentAim.SelectedPart = ClosestPart(tChar)
        if not SilentAim.SelectedPart then
            SilentAim.Selected, SilentAim.SelectedPart = nil, nil
            ReacquireTarget()
            return
        end
        tPart = SilentAim.SelectedPart
    end

    local predictedPos = getPredictedPosition(SilentAim.Selected) or tPart.Position
    StartAttachment.Parent = lChar.Head
    EndAttachment.Parent = tPart
    StartAttachment.WorldPosition = lChar.Head.Position
    EndAttachment.WorldPosition = predictedPos
    Beam.Enabled = true
end

local function UpdateTargetSelection()
    if SilentAim.TargetSelectionMode == "Auto" then
        GetClosest()
        if SilentAim.Selected and SilentAim.Selected ~= LocalPlayer then
            SilentAim.PreviousTarget = SilentAim.Selected
            MonitorDamage()
        end
    end
end

local healthConnection
local function MonitorDamage()
    if not SilentAim.Selected then
        warn("[DEBUG] MonitorDamage: No target selected")
        return
    end

    local success, err = pcall(function()
        if not SilentAim.Selected.Parent or not SilentAim.Selected:IsDescendantOf(Players) then
            warn("[DEBUG] MonitorDamage: Target player not in Players")
            return
        end

        local char = SilentAim.Selected.Character
        if not char or not char.Parent or not char:IsDescendantOf(Workspace) or not char:FindFirstChild("Humanoid") then
            warn("[DEBUG] MonitorDamage: Target character not found")
            return
        end

        if healthConnection then
            healthConnection:Disconnect()
            healthConnection = nil
        end

        local lastHealth = char.Humanoid.Health
        healthConnection = char.Humanoid:GetPropertyChangedSignal("Health"):Connect(function()
            local successInner, errInner = pcall(function()
                if not SilentAim.Selected or not SilentAim.Selected.Character or not SilentAim.Selected.Character:FindFirstChild("Humanoid") then
                    warn("[DEBUG] Health changed but target invalid, disconnecting")
                    if healthConnection then
                        healthConnection:Disconnect()
                        healthConnection = nil
                    end
                    return
                end

                local newHealth = char.Humanoid.Health
                local targetName = SilentAim.Selected.Name or "Unknown"
                warn("[DEBUG] Health changed for " .. targetName .. ": " .. tostring(lastHealth) .. " -> " .. tostring(newHealth))

                if newHealth < lastHealth then
                    ShowDamageIndicator(targetName, math.floor(lastHealth - newHealth), math.floor(newHealth))
                elseif newHealth <= 0 then
                    warn("[DEBUG] Target died, reacquiring")
                    ReacquireTarget()
                end
                lastHealth = newHealth
            end)
            if not successInner then warn("[DEBUG] Error in health change handler: " .. tostring(errInner)) end
        end)

        warn("[DEBUG] MonitorDamage: Health connection established for " .. (SilentAim.Selected.Name or "Unknown"))
    end)

    if not success then warn("[DEBUG] Error in MonitorDamage: " .. tostring(err)) end
end

-- Desync Stomp Logic with 3D Box ESP
local function createFollowPart()
    local part = Instance.new("Part")
    part.Name = "FollowPart"
    part.Anchored = true
    part.CanCollide = false
    part.Transparency = 1
    part.Size = Vector3.new(0.1, 0.1, 0.1)
    part.Parent = Workspace
    return part
end

local function createBoxESP()
    local box = {}
    for i = 1, 12 do
        local line = Drawing.new("Line")
        line.Visible = false
        line.Color = Color3.fromRGB(0, 255, 255)
        line.Thickness = 2
        line.Transparency = 1
        table.insert(box, line)
    end
    return box
end

local function updateBoxESP(box, position)
    if not Camera then return end

    local size = Vector3.new(2, 2, 2)
    local corners = {
        position + Vector3.new(-size.X/2, -size.Y/2, -size.Z/2),
        position + Vector3.new(size.X/2, -size.Y/2, -size.Z/2),
        position + Vector3.new(size.X/2, -size.Y/2, size.Z/2),
        position + Vector3.new(-size.X/2, -size.Y/2, size.Z/2),
        position + Vector3.new(-size.X/2, size.Y/2, -size.Z/2),
        position + Vector3.new(size.X/2, size.Y/2, -size.Z/2),
        position + Vector3.new(size.X/2, size.Y/2, size.Z/2),
        position + Vector3.new(-size.X/2, size.Y/2, size.Z/2)
    }

    local screenCorners = {}
    for i, corner in ipairs(corners) do
        local screenPos, onScreen = Camera:WorldToViewportPoint(corner)
        screenCorners[i] = {Vector2.new(screenPos.X, screenPos.Y), onScreen}
    end

    local lines = {{1, 2}, {2, 3}, {3, 4}, {4, 1}, {5, 6}, {6, 7}, {7, 8}, {8, 5}, {1, 5}, {2, 6}, {3, 7}, {4, 8}}

    local allOnScreen = true
    for _, corner in ipairs(screenCorners) do
        if not corner[2] then allOnScreen = false break end
    end

    for i, line in ipairs(lines) do
        box[i].Visible = allOnScreen
        if allOnScreen then
            box[i].From = screenCorners[line[1]][1]
            box[i].To = screenCorners[line[2]][1]
        end
    end
end

local function cleanupBoxESP(box)
    for _, line in ipairs(box) do line:Remove() end
end

local function setupDesync()
    if isDesyncActive then return end
    isDesyncActive = true
    followPart = createFollowPart()
    desyncBoxESP = createBoxESP()
    stompCounter = SilentAim.DesyncStomp.StompCount
    lastStompTime = tick()

    if SilentAim.DesyncStomp.UnequipWeaponDuringDesync then
        local equippedTool = Char and Char:FindFirstChildOfClass("Tool")
        if equippedTool then
            lastEquippedTool = equippedTool
            equippedTool.Parent = LocalPlayer.Backpack
            warn("[DEBUG] Weapon unequipped during desync: " .. equippedTool.Name)
        end
    end

    warn("[DEBUG] Desync started with stomp count: " .. tostring(stompCounter))
end

local function cleanupDesync()
    if not isDesyncActive then return end
    isDesyncActive = false
    if followPart then followPart:Destroy() followPart = nil end
    if desyncBoxESP then cleanupBoxESP(desyncBoxESP) desyncBoxESP = nil end
    stompCounter = 0
    lastStompTime = nil
    Camera.CameraSubject = Humanoid

    if SilentAim.DesyncStomp.UnequipWeaponDuringDesync and lastEquippedTool then
        if lastEquippedTool.Parent == LocalPlayer.Backpack then
            lastEquippedTool.Parent = Char
            warn("[DEBUG] Weapon re-equipped after desync: " .. lastEquippedTool.Name)
        end
        lastEquippedTool = nil
    end

    warn("[DEBUG] Desync cleaned up after stomp count reached 0")
end

local function performStomp()
    ReplicatedStorage.MainEvent:FireServer("Stomp")
    if ReplicatedStorage:FindFirstChild("assets") and ReplicatedStorage.assets:FindFirstChild("dh") then
        ReplicatedStorage.assets.dh.MainEvent:FireServer("Stomp")
    end
    stompCounter = stompCounter - 1
    lastStompTime = tick()
    warn("[DEBUG] Stomp called, remaining count: " .. tostring(stompCounter))
    if stompCounter <= 0 then cleanupDesync() end
end

local function MonitorKOState(targetPlayer)
    if not targetPlayer or not targetPlayer.Parent or not targetPlayer:IsDescendantOf(Players) then return end

    local char = targetPlayer.Character
    if not char or not char.Parent or not char:IsDescendantOf(Workspace) then return end

    local bodyEffects = char:FindFirstChild("BodyEffects")
    if not bodyEffects or not bodyEffects:FindFirstChild("K.O") then return end

    local ko = bodyEffects["K.O"]
    local currentKOState = ko.Value
    local lastKOState = targetKOStates[targetPlayer] and targetKOStates[targetPlayer].state or false

    if currentKOState ~= lastKOState then
        if not currentKOState then
            if targetPlayer and targetPlayer.Parent then
                desyncAppliedToTarget[targetPlayer] = nil
                warn("[DEBUG] Target " .. (pcall(function() return targetPlayer.Name end) and targetPlayer.Name or "Unknown") .. " exited K.O., desync flag reset")
            end
        end
        targetKOStates[targetPlayer] = targetKOStates[targetPlayer] or {}
        targetKOStates[targetPlayer].state = currentKOState
    end

    if not targetKOStates[targetPlayer] or not targetKOStates[targetPlayer].connection then
        local connection = ko:GetPropertyChangedSignal("Value"):Connect(function()
            if not targetPlayer or not targetPlayer.Parent or not targetPlayer:IsDescendantOf(Players) then
                if targetKOStates[targetPlayer] and targetKOStates[targetPlayer].connection then
                    targetKOStates[targetPlayer].connection:Disconnect()
                    targetKOStates[targetPlayer] = nil
                end
                return
            end

            local char = targetPlayer.Character
            if not char or not char.Parent or not char:IsDescendantOf(Workspace) then return end

            local bodyEffects = char:FindFirstChild("BodyEffects")
            if not bodyEffects or not bodyEffects:FindFirstChild("K.O") then return end

            local newKOState = bodyEffects["K.O"].Value
            targetKOStates[targetPlayer] = targetKOStates[targetPlayer] or { state = newKOState }
            if newKOState ~= targetKOStates[targetPlayer].state then
                if not newKOState then
                    desyncAppliedToTarget[targetPlayer] = nil
                    warn("[DEBUG] Target " .. (pcall(function() return targetPlayer.Name end) and targetPlayer.Name or "Unknown") .. " exited K.O., desync flag reset")
                end
                targetKOStates[targetPlayer].state = newKOState
            end
        end)
        targetKOStates[targetPlayer] = targetKOStates[targetPlayer] or {}
        targetKOStates[targetPlayer].connection = connection
    end
end

local function GetRagdollPart(char)
    if not char or not char.Parent or not char:IsDescendantOf(Workspace) then return nil end

    local upperTorso = char:FindFirstChild("UpperTorso")
    if upperTorso then return upperTorso end

    for _, partName in ipairs(SilentAim.TargetParts) do
        if partName == "HumanoidRootPart" then continue end
        if partName:find("Legs") then
            local combinedPart = GetCombinedPart(char, partName)
            if combinedPart then return combinedPart end
        else
            local part = char:FindFirstChild(partName)
            if part then return part end
        end
    end

    return nil
end

local function applyDesyncStomp()
    if not SilentAim.DesyncStomp.Enabled or not Check() then
        if isDesyncActive then cleanupDesync() end
        return
    end

    local targetPlayer = SilentAim.Selected
    if not targetPlayer or not targetPlayer.Parent or not targetPlayer:IsDescendantOf(Players) then
        if isDesyncActive then cleanupDesync() end
        return
    end

    local char = targetPlayer.Character
    if not char or not char.Parent or not char:IsDescendantOf(Workspace) then
        if isDesyncActive then cleanupDesync() end
        return
    end

    local bodyEffects = char:FindFirstChild("BodyEffects")
    local ko = bodyEffects and bodyEffects:FindFirstChild("K.O")
    if not ko or not ko.Value then
        if isDesyncActive then cleanupDesync() end
        return
    end

    local ragdollPart = GetRagdollPart(char)
    if not ragdollPart then
        if isDesyncActive then cleanupDesync() end
        return
    end

    MonitorKOState(targetPlayer)

    if not desyncAppliedToTarget[targetPlayer] then
        desyncAppliedToTarget[targetPlayer] = true
        if not isDesyncActive then setupDesync() end
    end

    if isDesyncActive then
        local currentTargetPosition = ragdollPart.Position
        local originalCFrame = HRP.CFrame
        local newCFrame = CFrame.new(currentTargetPosition + Vector3.new(0, SilentAim.DesyncStomp.YOffset, 0))

        followPart.CFrame = originalCFrame + Vector3.new(0, 1.5, 0)
        Camera.CameraSubject = followPart

        HRP.CFrame = newCFrame
        RunService.RenderStepped:Wait()
        HRP.CFrame = originalCFrame

        if desyncBoxESP then updateBoxESP(desyncBoxESP, newCFrame.Position) end

        if lastStompTime and (tick() - lastStompTime) >= SilentAim.DesyncStomp.StompInterval and stompCounter > 0 then
            performStomp()
        end
    end
end

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    
    if input.KeyCode == SilentAim.Keybind and SilentAim.TargetSelectionMode == "Keybind" then
        if SilentAim.Selected and SilentAim.Selected ~= LocalPlayer then
            SilentAim.Selected, SilentAim.SelectedPart, SilentAim.PreviousTarget = LocalPlayer, nil, nil
            if healthConnection then
                healthConnection:Disconnect()
                healthConnection = nil
            end
        else
            GetClosest()
            if SilentAim.Selected and SilentAim.Selected ~= LocalPlayer then
                SilentAim.PreviousTarget = SilentAim.Selected
                MonitorDamage()
            end
        end
    elseif input.KeyCode == SilentAim.ResolverKeybind then
        SilentAim.ResolverMode = SilentAim.ResolverMode == "Velocity" and "MoveDirection" or SilentAim.ResolverMode == "MoveDirection" and "CalculateCFrame" or "Velocity"
        warn("Resolver Mode: " .. SilentAim.ResolverMode)
    elseif input.KeyCode == SilentAim.DesyncStomp.ToggleKeybind then
        SilentAim.DesyncStomp.Enabled = not SilentAim.DesyncStomp.Enabled
        warn("Desync Stomp: " .. (SilentAim.DesyncStomp.Enabled and "Enabled" or "Disabled"))
        
        if SilentAim.IndicatorEnabled and Indicators.DesyncStompStatus then
            Indicators.DesyncStompStatus.TextLabel.Text = "Autostomp: " .. (SilentAim.DesyncStomp.Enabled and "Enabled" or "Disabled")
        end
        
        if not SilentAim.DesyncStomp.Enabled then
            desyncAppliedToTarget = {}
            if isDesyncActive then cleanupDesync() end
            isDesyncActive, followPart, desyncBoxESP, stompCounter, lastStompTime = false, nil, nil, 0, nil
            warn("[DEBUG] Desync Stomp data reset")
        end
    end
end)

Players.PlayerAdded:Connect(function(player)
    if SilentAim.KeepTargetOnDeath and SilentAim.PreviousTarget == player and SilentAim.ReacquisitionMode == "Immediate" then
        if player.Parent and player:IsDescendantOf(Players) then
            player.CharacterAdded:Connect(function(char)
                if not player or not player.Parent or not player:IsDescendantOf(Players) then return end
                SilentAim.Selected = player
                SilentAim.SelectedPart = ClosestPart(char)
                if SilentAim.SelectedPart then MonitorDamage() end
            end)
        end
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if SilentAim.Selected == player or SilentAim.PreviousTarget == player then
        SilentAim.Selected, SilentAim.SelectedPart, SilentAim.PreviousTarget = nil, nil, nil
        if healthConnection then
            healthConnection:Disconnect()
            healthConnection = nil
        end
        desyncAppliedToTarget[player] = nil
        if targetKOStates[player] and targetKOStates[player].connection then
            targetKOStates[player].connection:Disconnect()
        end
        targetKOStates[player] = nil
        ReacquireTarget()
    end
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if desyncAppliedToTarget[player] then
                desyncAppliedToTarget[player] = nil
                warn("[DEBUG] Target " .. (pcall(function() return player.Name end) and player.Name or "Unknown") .. " respawned, desync flag reset")
            end
            if targetKOStates[player] and targetKOStates[player].connection then
                targetKOStates[player].connection:Disconnect()
            end
            targetKOStates[player] = nil
            if SilentAim.Selected == player then
                SilentAim.SelectedPart = ClosestPart(char)
                if SilentAim.SelectedPart then MonitorDamage() end
            end
        end)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        player.CharacterAdded:Connect(function(char)
            if desyncAppliedToTarget[player] then
                desyncAppliedToTarget[player] = nil
                warn("[DEBUG] Target " .. (pcall(function() return player.Name end) and player.Name or "Unknown") .. " respawned, desync flag reset")
            end
            if targetKOStates[player] and targetKOStates[player].connection then
                targetKOStates[player].connection:Disconnect()
            end
            targetKOStates[player] = nil
            if SilentAim.Selected == player then
                SilentAim.SelectedPart = ClosestPart(char)
                if SilentAim.SelectedPart then MonitorDamage() end
            end
        end)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(newCharacter)
    Char = newCharacter
    HRP = Char:WaitForChild("HumanoidRootPart", 5) or error("HumanoidRootPart not found")
    Humanoid = Char:WaitForChild("Humanoid", 5) or error("Humanoid not found")
    if isDesyncActive then setupDesync() end
end)

local __index
__index = hookmetamethod(game, "__index", function(t, k)
    if t:IsA("Mouse") and (k == "Hit" or k == "Target") then
        if not Check() then return __index(t, k) end

        local selPart = SilentAim.SelectedPart
        if selPart then
            local predictedPos = getPredictedPosition(SilentAim.Selected) or selPart.Position
            return k == "Hit" and CFrame.new(predictedPos) or selPart
        end
    end
    return __index(t, k)
end)

RunService.Heartbeat:Connect(function()
    UpdateTracer()
    UpdateTargetSelection()
    UpdateIndicators()
    applyDesyncStomp()
end)

game:BindToClose(function()
    if Beam then Beam:Destroy() end
    if StartAttachment then StartAttachment:Destroy() end
    if EndAttachment then EndAttachment:Destroy() end
    if ScreenGui then ScreenGui:Destroy() end
    if watermark then watermark:Destroy() end
    if healthConnection then
        healthConnection:Disconnect()
        healthConnection = nil
    end
    if gradientAnimationConnection then
        gradientAnimationConnection:Disconnect()
        gradientAnimationConnection = nil
    end
    cleanupDesync()
    for player, data in pairs(targetKOStates) do
        if data and data.connection then data.connection:Disconnect() end
    end
    targetKOStates, desyncAppliedToTarget = {}, {}
end)

warn("Enhanced Silent Aim with Desync Stomp and 3D Box ESP loaded successfully!")
warn("Multi-Config Prediction: " .. (SilentAim.MultiConfigPredictionEnabled and "Enabled" or "Disabled"))
warn("Reacquisition Mode: " .. SilentAim.ReacquisitionMode)
warn("Resolver Mode: " .. SilentAim.ResolverMode)
warn("Desync Stomp: " .. (SilentAim.DesyncStomp.Enabled and "Enabled" or "Disabled"))
warn("Stomp Count: " .. tostring(SilentAim.DesyncStomp.StompCount))
warn("Stomp Interval: " .. tostring(SilentAim.DesyncStomp.StompInterval) .. " seconds")
warn("Unequip Weapon During Desync: " .. (SilentAim.DesyncStomp.UnequipWeaponDuringDesync and "Enabled" or "Disabled"))
warn("Press " .. tostring(SilentAim.ResolverKeybind) .. " to switch resolver modes")
warn("Press " .. tostring(SilentAim.DesyncStomp.ToggleKeybind) .. " to toggle Desync Stomp")
